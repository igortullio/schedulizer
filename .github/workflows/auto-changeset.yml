name: Auto Changeset

on:
  pull_request:
    types: [opened, edited]
    branches: [main]

jobs:
  auto-changeset:
    runs-on: ubuntu-latest

    # Skip if PR has changeset-release label (version PRs)
    if: ${{ !contains(github.event.pull_request.labels.*.name, 'changeset-release') }}

    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.RELEASE_APP_ID }}
          private-key: ${{ secrets.RELEASE_APP_PRIVATE_KEY }}

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0

      - name: Check if changeset already exists
        id: check_changeset
        run: |
          CHANGESET_FILES=$(git diff --name-only origin/main...HEAD | grep -E '^\.changeset/[^/]+\.md$' | grep -v 'README\.md' || true)
          if [[ -n "$CHANGESET_FILES" ]]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Changeset file already exists in this PR: $CHANGESET_FILES"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "No changeset file found in this PR"
          fi

      - name: Generate and push changeset via API
        if: steps.check_changeset.outputs.exists == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const prTitle = context.payload.pull_request.title;
            const prState = context.payload.pull_request.state;
            const prMerged = context.payload.pull_request.merged;

            if (prState !== 'open' || prMerged) {
              console.log('PR is already closed or merged, skipping');
              return;
            }

            const match = prTitle.match(/^(feat|fix|chore|refactor|docs|test|style|perf|ci|build)(\(.+\))?!?:\s(.+)$/);
            if (!match) {
              core.setFailed('PR title does not follow conventional commits pattern. Expected: type(scope): description');
              return;
            }

            const type = match[1];
            const description = match[3];
            const bumpLevel = type === 'feat' ? 'minor' : 'patch';

            const filename = `auto-${Date.now()}-${Math.floor(Math.random() * 100000)}`;
            const path = `.changeset/${filename}.md`;

            const packages = [
              '@schedulizer/api',
              '@schedulizer/web',
              '@schedulizer/landing',
              '@schedulizer/db',
              '@schedulizer/billing',
              '@schedulizer/email',
              '@schedulizer/observability',
              '@schedulizer/env',
              '@schedulizer/shared-types',
            ];

            const lines = ['---'];
            for (const pkg of packages) {
              lines.push(`"${pkg}": ${bumpLevel}`);
            }
            lines.push('---', '', description, '');

            const content = Buffer.from(lines.join('\n')).toString('base64');
            const branch = context.payload.pull_request.head.ref;

            await github.rest.repos.createOrUpdateFileContents({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path,
              message: 'chore: auto-generate changeset from PR title',
              content,
              branch,
            });

            console.log(`Created changeset: ${path}`);
            console.log(`Type: ${type} -> Bump level: ${bumpLevel}`);
            console.log(`Description: ${description}`);
